export class _RTJ{static customTypes=new Map;static registerType(e,t){_RTJ.customTypes.set(e.toLowerCase(),t)}constructor(e,t){try{this._type=this._parseType(t),this._observers=new Set,this._value=this._validateAndCoerce(e)}catch(e){throw e}}get value(){return this._value}set value(e){try{const t=this._validateAndCoerce(e);this._isEqual(this._value,t)||(this._value=t,this._notifyAll())}catch(e){throw e}}subscribe(e){try{return this._observers.add(e),()=>this._observers.delete(e)}catch(e){throw e}}_notifyAll(){try{this._observers.forEach((e=>e(this._value)))}catch(e){throw e}}_validateAndCoerce(e){try{if(this._type.validate(e))return this._type.coerce?this._type.coerce(e):e;throw new TypeError(`El valor debe ser de tipo ${this._type.name}`)}catch(e){throw e}}_validateType(e,t){try{const r=t.toLowerCase();switch(r){case"string":case"number":case"boolean":case"undefined":case"function":return typeof e===t;case"array":return Array.isArray(e);case"date":return e instanceof Date;case"object":return null!==e&&"object"==typeof e&&!Array.isArray(e);case"map":return e instanceof Map;case"set":return e instanceof Set;case"promise":return e instanceof Promise;case"regexp":return e instanceof RegExp}if(_RTJ.customTypes.has(r))return _RTJ.customTypes.get(r)(e);throw new TypeError(`Tipo no soportado: ${t}`)}catch(e){throw e}}_parseType(e){try{if(Array.isArray(e)&&e.length>0){const t=e.flat();return{name:`Array<${t.join("|")}>`,validate:e=>!!Array.isArray(e)&&e.every((e=>t.some((t=>this._validateType(e,t)))))}}return"string"==typeof e?{name:e,validate:t=>this._validateType(t,e)}:e}catch(e){throw e}}_isEqual(e,t){try{return Array.isArray(e)&&Array.isArray(t)?e.length===t.length&&e.every(((e,r)=>this._isEqual(e,t[r]))):e===t}catch(e){throw e}}}